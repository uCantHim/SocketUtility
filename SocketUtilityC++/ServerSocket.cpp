#include "ServerSocket.h"

#include <cassert>
#include <iostream>
#include <string>
#include <tuple>

#include "ClientSocket.h"
#include "SucInternals.h"



suc::ServerSocket::ServerSocket(int port, int family)
{
	bind(port, family);
}


suc::ServerSocket::~ServerSocket() noexcept
{
	try
	{
		close();
	}
	catch(const suc_error& e)
	{
		std::cerr << "In ServerSocket::~ServerSocket(): " << e.what() << '\n';
	}
}


suc::ServerSocket::ServerSocket(ServerSocket&& other) noexcept
{
	std::swap(_isClosed, other._isClosed);
	std::swap(socket, other.socket);

#ifdef OS_IS_WINDOWS
	std::swap(address, other.address);
#endif
#ifdef OS_IS_LINUX
	std::swap(address, other.address);
#endif
}


suc::ServerSocket& suc::ServerSocket::operator=(ServerSocket&& rhs) noexcept
{
	std::swap(_isClosed, rhs._isClosed);
	std::swap(socket, rhs.socket);

#ifdef OS_IS_WINDOWS
	std::swap(address, rhs.address);
#endif
#ifdef OS_IS_LINUX
	std::swap(address, rhs.address);
#endif

	return *this;
}


// ---------------------------------------- //
//											//
//			Windows Implementation			//
//											//
// ---------------------------------------- //

#ifdef OS_IS_WINDOWS

void suc::ServerSocket::bind(int port, int family)
{
	if (!(family == IPV4 || family == IPV6)) {
		throw value_error("Invalid family: " + std::to_string(family));
	}

	const auto address = family == IPV4 ? ADDR_LOCALHOST_4 : ADDR_LOCALHOST_6;
	addrinfo* ptr = sucTranslateAddress(address, port, family, SOCK_STREAM, IPPROTO_TCP, AI_PASSIVE);
	int iResult = 0;

	// Try to bind to any of the returned connections
	for (; ptr != nullptr; ptr = ptr->ai_next)
	{
		socket = winsock_socket(ptr->ai_family, ptr->ai_socktype, ptr->ai_protocol);
		if (socket == INVALID_SOCKET)
		{
			// Do nothing, just try the next address
			continue;
		}

		_isClosed = false;
		iResult = winsock_bind(socket, ptr->ai_addr, static_cast<int>(ptr->ai_addrlen));
		if (iResult == SOCKET_ERROR) {
			handleLastError();
		}

		address = ptr;
		break;
	}
	if (socket == INVALID_SOCKET) {// No valid address was generated by sucTranslateAddress()
		handleLastError();
	}

	// Listen
	iResult = winsock_listen(socket, SOMAXCONN);
	if (iResult == SOCKET_ERROR) {
		throw network_error("Error in ServerSocket::bind() when trying to listen. ["
			+ std::to_string(WSAGetLastError()) + "]");
	}
}


std::unique_ptr<suc::ClientSocket> suc::ServerSocket::accept() const
{
	SOCKET s = winsock_accept(socket, nullptr, nullptr);

	if (s == INVALID_SOCKET)
	{
		handleLastError();
	}


	// Create ClientSocket
	auto newClient = std::make_unique<ClientSocket>(s);
	return newClient;
}


void suc::ServerSocket::close()
{
	if (_isClosed) { return; }

	int iResult = closesocket(socket);
	if (iResult == SOCKET_ERROR && WSAGetLastError() != WSAENOTSOCK)
	{
		handleLastError();
	}

	_isClosed = true;
}

#endif


// ------------------------------------ //
//										//
//			Linux Implementation		//
//										//
// ------------------------------------ //

#ifdef OS_IS_LINUX

// Sources:
// https://www.linuxhowtos.org/C_C++/socket.htm

void suc::ServerSocket::bind(int port, int family)
{
	if (!(family == IPV4 || family == IPV6)) {
		throw value_error("Invalid family: " + std::to_string(family));
	}

	// Create a new socket
	/* AF_INET is internet, AF_UNIX is a unix socket for two processes that
	 * share a common file system.
	 *
	 * SOCK_STREAM is a contiguous stream of data, SOCK_DGRAM is a connection
	 * in which messages are read in chunks.
	 *
	 * 0 indicates that the operating system shall choose the most appropriate
	 * protocol. This should almost always be 0. It will choose TCP for
	 * SOCK_STREAM, UDP for SOCK_DGRAM.
	 */
	socket = linux_socket(family, SOCK_STREAM, 0);
	if (socket == -1)
		throw network_error("[Linux] Unable to create a socket.");

	// Initialize address to zero
	memset(&address, 0, sizeof(address));
	address.sin_family = family;
	address.sin_port = htons(port);
	address.sin_addr.s_addr = INADDR_ANY;

	int result = linux_bind(socket, reinterpret_cast<sockaddr*>(&address), sizeof(address));
	if (result == -1)
		handleLastError();

	// Listen
	const int backlogQueueSize = 5; // Maximum on most systems
	linux_listen(socket, backlogQueueSize); // Cannot fail if the first argument is a valid socket descriptor
}


auto suc::ServerSocket::accept() const -> std::unique_ptr<suc::ClientSocket>
{
	sockaddr_in clientAddress{};
	int addressLength = sizeof(clientAddress);
	SOCKET newSock = linux_accept(
		socket,
		reinterpret_cast<sockaddr*>(&clientAddress),
		reinterpret_cast<socklen_t*>(&addressLength)
	);

	if (newSock == -1)
		throw network_error("[Linux] Unable to accept connection.");

	// Create ClientSocket
	auto newClient = std::make_unique<ClientSocket>(newSock);
	return newClient;
}


void suc::ServerSocket::close()
{
	if (_isClosed) { return; }

	if (linux_close(socket))
		throw network_error("[Linux] Unable to close socket.");

	_isClosed = true;
}

#endif


bool suc::ServerSocket::isClosed() const noexcept
{
	return _isClosed;
}
