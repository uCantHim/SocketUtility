#include "ClientSocket.h"

#include "SucInternals.h"



suc::ClientSocket::ClientSocket(SOCKET socket) noexcept
	:
	socket(socket)
{
}


suc::ClientSocket::~ClientSocket() noexcept
{
	try
	{
		close();
	}
	catch(const suc_error& e)
	{
		std::cerr << "In ClientSocket::~ClientSocket(): " << e.what() << '\n';
	}
}


suc::ClientSocket::ClientSocket(ClientSocket&& other) noexcept
{
	std::swap(socket, other.socket);
	std::swap(recvbuf, other.recvbuf);
	std::swap(_isClosed, other._isClosed);
}


suc::ClientSocket& suc::ClientSocket::operator=(ClientSocket&& rhs) noexcept
{
	std::swap(socket, rhs.socket);
	std::swap(recvbuf, rhs.recvbuf);
	std::swap(_isClosed, rhs._isClosed);

	return *this;
}


// ---------------------------------------- //
//											//
//			Windows Implementation			//
//											//
// ---------------------------------------- //

#ifdef OS_IS_WINDOWS

bool suc::ClientSocket::connect(std::string ip, int port, int family)
{
	if (!_isClosed) { close(); }

	if (ip.empty()) {
		ip = ADDR_LOCALHOST_4;
	}

	addrinfo* ptr = sucTranslateAddress(ip, port, family, SOCK_STREAM, IPPROTO_TCP, NULL);
	int iResult = 0;

	for (; ptr != nullptr; ptr = ptr->ai_next)
	{
		// Create socket
		socket = winsock_socket(ptr->ai_family, ptr->ai_socktype, ptr->ai_protocol);
		if (socket == INVALID_SOCKET)
		{
			// Do nothing, just try the next address
			continue;
		}

		iResult = winsock_connect(socket, ptr->ai_addr, static_cast<int>(ptr->ai_addrlen));
		if (iResult != SOCKET_ERROR)
		{
			_isClosed = false;
			return true;
		}

		handleLastError();
	}
	// No valid address was generated by sucTranslateAddress().
	handleLastError();
	return false;
}


void suc::ClientSocket::send(const sbyte* buf, uint size)
{
	int bytesSent = winsock_send(socket, buf, static_cast<int>(size), NULL);
	if (bytesSent < 0) {
		handleLastError();
	}
	assert(bytesSent == static_cast<int>(size));
}


suc::uint suc::ClientSocket::recv(sbyte* buf, int timeoutMS)
{
	if (!hasData(timeoutMS)) {
		return 0U;
	}

	int bytes = winsock_recv(socket, recvbuf.data(), static_cast<int>(recvbuf.size()), NULL);
	if (bytes > recvbuf.size() - REMAINING_BUF_SPACE_CAP)
	{
		recvbuf.resize(recvbuf.size() * 2);
	}

	if (bytes > 0) // Received data
	{
		memcpy(buf, recvbuf.data(), static_cast<size_t>(bytes));
		return static_cast<uint>(bytes);
	}
	if (bytes == 0) // Connection has been closed remotely
	{
		throw network_error("Connection closed remotely.");
	}

	handleLastError();
}


bool suc::ClientSocket::hasData(int timeoutMS) const
{
	constexpr std::int32_t secondsFactor = 1000L;
	timeval timeout;
	timeout.tv_usec = static_cast<std::int32_t>(timeoutMS) % secondsFactor;
	timeout.tv_sec = (static_cast<std::int32_t>(timeoutMS) - timeout.tv_usec) / secondsFactor;

	fd_set read{ 1, {socket} };
	int numSockets = winsock_select(NULL, &read, nullptr, nullptr, timeoutMS != -1 ? &timeout : nullptr);
	if (numSockets == -1)
		handleLastError();

	return numSockets > 0;
}


void suc::ClientSocket::close()
{
	if (_isClosed) { return; }

	int iResult = closesocket(socket);
	if (iResult == SOCKET_ERROR && WSAGetLastError() != WSAENOTSOCK)
	{
		handleLastError();
	}

	_isClosed = true;
}

#endif // #ifdef OS_IS_WINDOWS



// ------------------------------------ //
//										//
//			Linux Implementation		//
//										//
// ------------------------------------ //

#ifdef OS_IS_LINUX

bool suc::ClientSocket::connect(std::string ip, int port, int family)
{
	if (!_isClosed) { close(); }

	if (ip.empty()) {
		ip = ADDR_LOCALHOST_4;
	}

	// Create a new socket
	/* AF_INET is internet, AF_UNIX is a unix socket for two processes that
	 * share a common file system.
	 *
	 * SOCK_STREAM is a contiguous stream of data, SOCK_DGRAM is a connection
	 * in which messages are read in chunks.
	 *
	 * 0 indicates that the operating system shall choose the most appropriate
	 * protocol. This should almost always be 0. It will choose TCP for
	 * SOCK_STREAM, UDP for SOCK_DGRAM.
	 */
	socket = linux_socket(family, SOCK_STREAM, 0);
	if (socket == -1)
		handleLastError();

	// Resolve host address
	hostent* server = gethostbyname(ip.c_str());
	if (server == nullptr)
		handleLastError();

	// Create server address structure
	sockaddr_in serverAddress{};
	memset(&serverAddress, 0, sizeof(serverAddress));

	serverAddress.sin_family = family;
	memcpy(&serverAddress.sin_addr.s_addr, server->h_addr, server->h_length);
	serverAddress.sin_port = htons(port);

	// Connect
	int result = linux_connect(socket, reinterpret_cast<sockaddr*>(&serverAddress), sizeof(serverAddress));
	if (result == -1)
		handleLastError();

	return true;
}


void suc::ClientSocket::send(const sbyte* buf, uint size)
{
	ssize_t writtenBytes = write(socket, buf, static_cast<size_t>(size));
	if (writtenBytes < 0)
		handleLastError();

	assert(writtenBytes == static_cast<ssize_t>(size));
}




suc::uint suc::ClientSocket::recv(sbyte* buf, int timeoutMS)
{
	if (!hasData(timeoutMS)) {
		return 0U;
	}

	int readBytes = read(socket, recvbuf.data(), recvbuf.size());
	if (readBytes > recvbuf.size() - REMAINING_BUF_SPACE_CAP)
	{
		recvbuf.resize(recvbuf.size() * 2);
	}

	if (readBytes > 0) // Received data
	{
		memcpy(buf, recvbuf.data(), static_cast<size_t>(readBytes));
		return static_cast<uint>(readBytes);
	}
	if (readBytes == 0) // Connection has been closed remotely
	{
		handleLastError();
	}

	handleLastError();
}


bool suc::ClientSocket::hasData(int timeoutMS) const
{
	// select() is POSIX-standardized but I still wrote a separate implementation
	// for it. I shall look into this.
	fd_set read;
	FD_SET(socket, &read);

	constexpr std::int32_t secondsFactor = 1000L;
	timeval timeout{};
	timeout.tv_usec = static_cast<std::int32_t>(timeoutMS) % secondsFactor;
	timeout.tv_sec = (static_cast<std::int32_t>(timeoutMS) - timeout.tv_usec) / secondsFactor;

	timeval* t_ptr = &timeout;
	if (timeoutMS == -1)
		t_ptr = nullptr;

	int numSockets = select(socket + 1, &read, nullptr, nullptr, t_ptr);
	if (numSockets == -1)
		handleLastError();

	return numSockets > 0;
}


void suc::ClientSocket::close()
{
	if (_isClosed) { return; }

	if (linux_close(socket) == -1)
		handleLastError();

	_isClosed = true;
}

#endif // #ifdef OS_IS_LINUX


void suc::ClientSocket::send(const std::vector<sbyte>& buf)
{
	send(buf.data(), static_cast<uint>(buf.size()));
}


void suc::ClientSocket::sendString(const std::string& to_str)
{
	send(static_cast<const sbyte*>(to_str.c_str()), static_cast<uint>(to_str.size()));
}


std::optional<std::vector<suc::sbyte>> suc::ClientSocket::recv(int timeoutMS)
{
	uint bytes = recv(recvbuf.data(), timeoutMS);
	if (bytes == 0) {
		return std::nullopt;
	}

	return recvbuf;
}


std::string suc::ClientSocket::recvString(int timeoutMS)
{
	uint bytes = recv(recvbuf.data(), timeoutMS);
	if (bytes == 0) {
		return std::string();
	}

	return std::string{ recvbuf.data(), bytes };
}


bool suc::ClientSocket::isClosed() const noexcept
{
	return _isClosed;
}
